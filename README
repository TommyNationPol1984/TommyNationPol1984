Overview
Liberty Echo is a production‑grade voice cloning and expressive TTS platform built with a consent‑first approach. It combines zeroshot and fewshot cloning, SSML‑aware streaming synthesis, multilingual phonemization, timing‑accurate dubbing, and a note‑driven singing studio. The project is designed for ethical audio generation with tamper‑evident consent logs, watermarking, and abuse detection.

Key Features
Consent and audit tamper‑evident logs and one‑click revoke/purge.

Voice cloning zeroshot embedding extraction and fewshot LoRA adapters.

Expressive synthesis SSML support, emotion presets, continuous prosody controls.

Dubbing and voice conversion forced alignment, strict timing modes, formant preservation.

Singing studio MIDI import, F0 editor, vibrato and breath controls, stems export.

Multilingual stack shared phoneme inventory, G2P per language, codeswitching support.

Production exports WAV 48k/24bit, WAV 24k/16bit, MP3, M4A with LUFS normalization.

Safety watermarking default ON, public figure and minor detection, abuse filters.

Quickstart
Clone the repo

bash
git clone https://github.com/your-org/liberty-echo.git
cd liberty-echo
Frontend dev server

bash
cd frontend
npm install
npm run dev
Backend dev server

bash
cd backend
pip install -r requirements.txt
uvicorn app.main:app --reload
Run tests

bash
# frontend
cd frontend
npm test

# backend
cd backend
pytest
Repository Layout
Code
/liberty-echo
├─ /frontend        # React/Next UI, component library, Figma tokens
├─ /backend         # API services: synth, clone, dub, admin
├─ /models          # Model wrappers, LoRA adapters, vocoder integrations
├─ /inference       # Streaming inference, batching, caching
├─ /tools           # Audio utilities: alignment, G2P, postFX chain
├─ /ops             # Deployment manifests, monitoring, SLOs
├─ /docs            # Architecture, API contracts, consent templates
└─ README.md
API Contract Stubs
POST /api/clone  
Payload: voice_name, consent_proof_id, samples[], language_tags, region  
Response: clone_id, fidelity_estimate, status

POST /api/synthesize  
Payload: text_or_ssml, voice_id, emotion, intensity, pitch, rate, format, sample_rate  
Response: streaming handle or job_id

POST /api/dub  
Payload: source_audio_ref, transcript_ref, target_voice_id, timing, formant_preserve  
Response: job_id, preview_url

POST /api/revoke  
Payload: clone_id, requester_id, reason  
Response: status, purge_job_id

Ethics and Licensing
Consent required no cloning without written consent and ID verification.

Watermarking generated audio must include provenance metadata and audible/inaudible watermarking where applicable.

Abuse prevention public figure and minor detection blocks; exports labeled “Synthetic audio generated by AI.”

Include your project license file and legal templates in /docs before public release.

Contributing Guide
How to contribute
Fork the repo and open a pull request against main.

Use feature branches named feat/<short-description> or fix/<short-description>.

Include tests and update docs for any user‑facing change.

Development setup
Follow Quickstart in README to run frontend and backend locally.

Use the provided Docker compose in /ops for an integrated local stack when available.

Coding standards
Frontend React + TypeScript. Follow ESLint and Prettier rules in the repo.

Backend Python 3.10+ with FastAPI. Follow Black and isort.

Write clear, testable functions and include docstrings for public modules.

Testing and QA
Unit tests required for new features. Aim for meaningful coverage on core logic (audio pipeline, consent gating, alignment).

Include integration tests for API endpoints and a smoke test for streaming synth.

Add accessibility tests for UI components and verify WCAG AA compliance for key flows.

Security and consent handling
Encrypt uploads in transit and at rest. Do not store raw audio beyond consent verification unless explicitly authorized.

Implement one‑click purge that triggers model purge flags and audit entries.

Add automated checks for public figure and minor detection in the ingestion pipeline.

Issue and PR process
Link issues to PRs and include a short testing checklist in PR descriptions.

Maintain a changelog and tag releases semantically.
